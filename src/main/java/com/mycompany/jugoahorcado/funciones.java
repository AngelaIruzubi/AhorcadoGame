package com.mycompany.jugoahorcado;import java.io.BufferedReader;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStreamReader;import java.util.Arrays;import java.util.Scanner;import java.util.regex.Pattern;/** * Clase que contiene las funciones principales para el juego del ahorcado. * Incluye métodos para generar partes del ahorcado, leer palabras, limpiar * texto y manejar la lógica relacionada con las palabras del juego. * * @author Ángela */public class funciones {    //GENERO EL DIBUJO DEL AHORCADO    /**     * Genera un String que va generarndo el ahorcado.     *     * @param partes     * @return Un String que va uniendo las partes del cuerpo     */    public static String generarAhorcado(String[] partes) {        StringBuilder resultado = new StringBuilder();        for (String parte : partes) {            resultado.append(parte + "\n");        }        return resultado.toString();    }    /**     * Genera un String que representa la cabeza del ahorcado.     *     * @return Un String que dibuja la cabeza del ahorcado en forma de     * asteriscos.     */    public static String cabezaAhorcado() {        String[] partes = {            "*******",            "*    ***",            "*     *",            "*",            "*",            "****",            "****",            "****",            "****",            "****",};        return generarAhorcado(partes);    }    /**     * Genera un String que representa el tronco del ahorcado.     *     * @return Un String que dibuja el tronco del ahorcado en forma de     * asteriscos.     */    public static String troncoAhorcado() {        String[] partes = {            "*******",            "*    ***",            "*     *",            "*     *",            "*     *",            "***",            "***",            "***",            "***",            "***",};        return generarAhorcado(partes);    }    /**     * Genera un String que representa el brazo derecho del ahorcado.     *     * @return Un String que dibuja el brazo derecho del ahorcado en forma de     * asteriscos.     */    public static String brazoDechAhorcado() {        String[] partes = {            "*******",            "*    ***",            "*     *",            "*     ****",            "*     *",            "***",            "***",            "***",            "***",            "***",};        return generarAhorcado(partes);    }    /**     * Genera un String que representa el brazo izquierdo del ahorcado.     *     * @return Un String que dibuja el brazo izquierdo del ahorcado en forma de     * asteriscos.     */    public static String brazoIzqAhorcado() {        String[] partes = {            "*******",            "*    ***",            "*     *",            "*  *******",            "*     *",            "***",            "***",            "***",            "***",            "***",};        return generarAhorcado(partes);    }    /**     * Genera un String que representa la pierna derecha del ahorcado.     *     * @return Un String que dibuja la pierna derecha del ahorcado en forma de     * asteriscos.     */    public static String piernaDechAhorcado() {        String[] partes = {            "*******",            "*    ***",            "*     *",            "*  *******",            "*     *",            "***     *",            "***       *",            "***",            "***",            "***",};        return generarAhorcado(partes);    }    /**     * Genera un String que representa la pierna izquierda del ahorcado.     *     * @return Un String que dibuja la pierna izquierda del ahorcado en forma de     * asteriscos.     */    public static String piernaIzqAhorcado() {        String[] partes = {            "*******",            "*    ***",            "*     *",            "*  *******",            "*     *",            "***  *  *",            "*** *    *",            "***",            "***",            "***",};        return generarAhorcado(partes);    }    //TRATAMIENTO DEL TEXTO    /**     * Lee las palabras de un archivo de texto linea a linea y las convierte en     * un array de palabras.     *     * @param texto Ruta del archivo de texto a leer.     * @return Un array con las palabras leídas del archivo.     * @throws FileNotFoundException Si el archivo no se encuentra.     * @throws IOException Si ocurre un error al leer el archivo.     */    public static String[] leerSepararPalabras(String texto) throws FileNotFoundException, IOException {        //revisar        String[] palabras = new String[15000];        int cont = 0;        //Busque en internet una forma para que no hubiera problemas con los acentos,ñ y encontre esta forma de tratar         //el BufferReader en donde hay que indicarle la codificación del texto.        BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(texto), "UTF-8"));        String linea, lineaSinAcentos;        while ((linea = br.readLine()) != null) {            lineaSinAcentos = limpiarPalabras(linea);            String[] palabrasLinea = lineaSinAcentos.split("[^A-ZÜÑ]+");            // Añadir las palabras al array hasta que esté lleno            for (String palabra : palabrasLinea) {                if (cont < palabras.length) {                    palabras[cont] = palabra;                    cont++;                }            }        }        // Crear un array del tamaño exacto de las palabras encontradas        String[] resultado = new String[cont];        for (int i = 0; i < cont; i++) {            resultado[i] = palabras[i];        }        return resultado;    }    /**     * Limpia un texto eliminando los acentos y convirtiendo todas las letras a     * mayúsculas.     *     * @param texto El texto a limpiar.     * @return El texto limpio sin acentos y en mayúsculas.     */    public static String limpiarPalabras(String texto) {        StringBuilder resultado = new StringBuilder();        texto = texto.toUpperCase(); // Convertir todo a mayúsculas        for (int i = 0; i < texto.length(); i++) {            char c = texto.charAt(i);            switch (c) {// Reemplazar vocales con acentos por su equivalente sin acento                case 'Á':                    resultado.append('A');                    break;                case 'É':                    resultado.append('E');                    break;                case 'Í':                    resultado.append('I');                    break;                case 'Ó':                    resultado.append('O');                    break;                case 'Ú':                    resultado.append('U');                    break;                case 'Ü':                    resultado.append('U');                    break;                case 'Ñ':                    resultado.append('Ñ');                    break; // Conservar la Ñ tal cual                case 'N':                    // El programa descompone la ñ en dos en una n y el acento ~                     //El codigo unicode \u0303 es el del acento.El siguiente if compruebasi es n o ñ                    if (i + 1 < texto.length() && texto.charAt(i + 1) == '\u0303') {                        resultado.append('Ñ');                        i++;                    } else {                        resultado.append('N');                    }                    break;                default:                    if ((c >= 'A' && c <= 'Z') || c == ' ') {                        resultado.append(c); // Añade letras y espacios                    }                    break;            }        }        return resultado.toString();    }    /**     * Filtra las palabras del texto principal eliminando las palabras que     * coincidan con una lista de palabras de "stop words".     *     * @param palabrasQuijote Array con las palabras principales.     * @param palabrasStop Array con las palabras de "stop words".     * @return Un array con las palabras filtradas.     * @throws IOException Si ocurre un error durante la operación.     */    public static String[] eliminarPalbrasStop(String[] palabrasQuijote, String[] palabrasStop) throws IOException {        int index = 0;        String[] palabrasAhorcadoTemp = new String[palabrasQuijote.length];        for (int i = 0; i < palabrasQuijote.length; i++) {            boolean esStopWord = false;            // Verificar si la palabra actual está en palabrasStop            for (int j = 0; j < palabrasStop.length; j++) {                if (palabrasQuijote[i].equals(palabrasStop[j])) {                    esStopWord = true;                    break; // Salir del bucle si encontramos la palabra en stop                }            }            // Si no es una stop word, agregarla al arreglo temporal            if (!esStopWord) {                palabrasAhorcadoTemp[index] = palabrasQuijote[i];                index++;            }        }        // Crear un nuevo arreglo con el tamaño exacto        String[] palabrasAhorcado = new String[index];        for (int k = 0; k < index; k++) {            palabrasAhorcado[k] = palabrasAhorcadoTemp[k];        }        return palabrasAhorcado;    }    /**     * Filtra las palabras para que solo se incluyan las que tienen 5 o más     * caracteres.     *     * @param palabrasAhorcado Array con las palabras a filtrar.     * @return Un array con las palabras que cumplen el criterio de longitud.     */    public static String[] palabras5caracteres(String[] palabrasAhorcado) {        int tamano = 5, index = 0;        String[] palabrasTamanotemp = new String[palabrasAhorcado.length];        for (int i = 0; i < palabrasAhorcado.length; i++) {            char[] caract = palabrasAhorcado[i].toCharArray();            if (caract.length >= tamano) {                palabrasTamanotemp[index] = palabrasAhorcado[i];                index++;            }        }        String[] palabrasTamano = new String[index];        for (int k = 0; k < index; k++) {            palabrasTamano[k] = palabrasTamanotemp[k];        }        return palabrasTamano;    }    //funcion para eliminar palabras repetidas    /**     * Selecciona una palabra al azar de un array de palabras.     *     * @param palabrasTamano Array con las palabras candidatas.     * @return Una palabra seleccionada al azar.     */    public static String[] palabraRandom(String[] palabrasTamano) {        int numero = (int) (Math.random() * (palabrasTamano.length));        int tamano = palabrasTamano[numero].length();        String[] palabraSecreta = new String[tamano];                  for(int i=0;i<palabraSecreta.length;i++){             palabraSecreta[i]= String.valueOf(palabrasTamano[numero].charAt(i));         }                 return palabraSecreta;     }    /**     * Crea un arreglo de guiones representando la palabra secreta. Cada     * carácter en la palabra es representado inicialmente como "_ ".     *     * @param palabraSecreta La palabra que debe ser adivinada.     * @return Un array de guiones con la misma longitud que la palabra secreta.     */    public static String[] crearGuiones(String[]palabraSecreta) {        int tamano = palabraSecreta.length;        String[] guiones = new String[tamano];        for (int i = 0; i < tamano; i++) {            guiones[i] = "_ ";        }        return guiones;    }    /**     * Verifica si una letra específica está presente en la palabra secreta.     *     * @param letra La letra a buscar.     * @param palabraSecreta La palabra secreta en la que buscar la letra.     * @return {@code true} si la letra está presente; {@code false} en caso     * contrario.     */ public static boolean estaLetra(char letra, String[] palabraSecreta) {    for (int i = 0; i < palabraSecreta.length; i++) {        if (palabraSecreta[i] != null && palabraSecreta[i].equals(String.valueOf(letra))) {            return true;  // La letra fue encontrada        }    }    return false;  // La letra no está en la palabra}    /**     * Rellena el arreglo de guiones con la letra proporcionada en las     * posiciones correspondientes.     *     * @param guiones El arreglo de guiones que representa el progreso actual.     * @param letra La letra a insertar.     * @param palabraSecreta La palabra secreta donde buscar la letra.     * @return El array de guiones actualizado.     */    public static String[] rellenar(String[] guiones, char letra, String[] palabraSecreta) {        for (int i = 0; i < palabraSecreta.length; i++) {            if (palabraSecreta[i].charAt(0)==letra) {                guiones[i] = String.valueOf(letra);            }        }        return guiones;    }    /**     * Verifica si el carácter proporcionado es una vocal (mayúscula).     *     * Este método recibe un carácter como argumento y determina si dicho     * carácter es una vocal mayúscula ('A', 'E', 'I', 'O', 'U'). Devuelve     * `true` si el carácter es una vocal, y `false` en caso contrario.     *     * @param letra El carácter que se va a verificar.     * @return `true` si el carácter es una vocal, `false` si no lo es.     */    public static boolean esVocal(char letra) {        boolean estaVocal = false;        char[] vocales = {'A', 'E', 'I', 'O', 'U'};        for (int i = 0; i < vocales.length; i++) {            if (letra == vocales[i]) {                estaVocal = true;                break;            } else {                estaVocal = false;            }        }        return estaVocal;    }    /**     * Ofrece una vocal de la palabra secreta al jugador, si existe y no ha sido     * revelada.     *     * @param guiones El arreglo de guiones que representa el progreso actual.     * @param palabraSecreta La palabra secreta en juego.     */    public static void darVocal(String[] guiones, String [] palabraSecreta) {         boolean existeLetra = false;        char[] vocales = {'A', 'E', 'I', 'O', 'U'};        for (int i = 0; i < vocales.length; i++) {            for (int l = 0; l < palabraSecreta.length; l++) {                if ((String.valueOf(vocales[i]).equals(palabraSecreta[l])) && (!estaLetra(vocales[i], guiones))) {                    rellenar(guiones, vocales[i], palabraSecreta);                    existeLetra = true;                    break;                }            }            if (existeLetra) {                break;            }        }        System.out.println("Asi queda la palabra" + Arrays.toString(guiones));    }    /**     * Ofrece una consonante de la palabra secreta al jugador, si existe y no ha     * sido revelada.     *     * @param guiones El arreglo de guiones que representa el progreso actual.     * @param palabraSecreta La palabra secreta en juego.     */    public static void darConsonante(String[] guiones, String[]palabraSecreta) {              boolean existeLetra = false;        for (int i = 0; i < palabraSecreta.length; i++) {            char letra = palabraSecreta[i].charAt(0);            if (!estaLetra(letra, guiones) && !esVocal(letra)) {                rellenar(guiones, letra, palabraSecreta);                existeLetra = true;                break;            }        }        System.out.println("Asi queda la palabra" + Arrays.toString(guiones));    }    /**     * Verifica si la palabra secreta ha sido completada.     *     * Este método revisa si todos los guiones han sido reemplazados por las     * letras correctas, lo que indicaría que el jugador ha adivinado la palabra     * secreta y ha ganado.     *     * @param guiones Un arreglo de cadenas que representan la palabra oculta     * con guiones.     * @param palabraSecreta La palabra completa que el jugador debe adivinar.     */    public static void verificarPalabraCompletada(String[] guiones, String [] palabraSecreta) {        String palabraAdivinada = "";        for (String guion : guiones) {            palabraAdivinada += guion;        }        // Si todos los guiones se han reemplazado, el jugador ha ganado        if (palabraAdivinada.equals(palabraSecreta)) {            System.out.println("¡Has ganado! La palabra es: " + Arrays.toString(palabraSecreta));            System.exit(0);  // Finaliza el juego        }    }    /**     * Muestra las reglas del juego del ahorcado al usuario.     * <p>     * Este método imprime una descripción detallada de cómo jugar el juego, las     * reglas, y consejos para ganar. Es llamado al inicio del juego para     * preparar al usuario.     */    public static void imprimirReglas() {        System.out.println("""                           Prep\u00e1rate para poner a prueba tu ingenio y vocabulario en este emocionante desaf\u00edo.                           El objetivo es sencillo: adivina la palabra oculta letra por letra antes de que el dibujo del ahorcado se complete.                                                      Reglas del juego:                                                      Piensa bien antes de elegir, porque cada error a\u00f1adir\u00e1 una parte al dibujo.                           \u00a1Tienes 6 intentos para salvar al ahorcado!                           A mitad de partida podr\u00e1s rendirte marcando el -1                           Pero recuerda que a los 3 fallos te daremos una pista que podr\u00e1 ser aleatoriamente:                           Eliminar un fallo de la horca                           Vocal extra sin que suponga fallo                           Consonante extra sin que suponda fallo:                           Si logras completar la palabra antes de perder todos los intentos, \u00a1ganas!                           Consejos:                                                      Utiliza tus habilidades deductivas y empieza por las vocales.                           \u00a1No tengas miedo de arriesgarte, pero juega con estrategia!                           \u00bfEst\u00e1s listo para demostrar tu habilidad? \u00a1La diversi\u00f3n comienza ahora!                           Para comenzar marca SI""");    }    /**     * Gestiona las opciones de ayuda disponibles para el jugador.     * <p>     * Este método se ejecuta cuando el jugador alcanza 3 fallos. Permite al     * jugador recibir una pista aleatoria que puede ayudarle a continuar. El     * método decide si debe ofrecer una vocal, una consonante o una opción     * general de ayuda.     *     * @param fallos un array que representa el número actual de fallos.     * @param guiones un array de cadenas que representa el estado actual de la     * palabra oculta.     * @param palabraSecreta la palabra secreta que el jugador está intentando     * adivinar.     */    public static void gestionAyuda(int[] fallos, String[] guiones, String [] palabraSecreta) {        boolean vocal = false;        boolean consonante = false;        char letra;        for (int i = 0; i < guiones.length; i++) {            letra = palabraSecreta[i].charAt(0);            if (guiones[i].charAt(0) != letra) {                if (esVocal(letra)) {                    vocal = true;                    break;                } else {                    consonante = true;                }                if (vocal && consonante) {                    break;                }            } else {            }        }        if (vocal && consonante) {            proporcionarAyuda(fallos, guiones, palabraSecreta, 3);        } else if (!vocal && consonante) {            proporcionarAyuda(fallos, guiones, palabraSecreta, 2);        } else if (vocal && !consonante) {            proporcionarAyuda(fallos, guiones, palabraSecreta, 2);        } else {            mostrarOpcionesAyuda();            System.out.println("Te he eliminado un fallo.");            fallos[0]--;        }    }    /**     * Proporciona una pista al jugador, ya sea eliminando un fallo, añadiendo     * una vocal o consonante a la palabra oculta, o una combinación de estos.     * <p>     * El tipo de pista se selecciona aleatoriamente entre las opciones     * disponibles. La pista se entrega sin sumar fallos adicionales y el estado     * de la palabra oculta se actualiza en consecuencia.     *     * @param fallos un array que representa el número actual de fallos     * cometidos por el jugador. El valor en la posición 0 indica los fallos.     * @param guiones un arreglo de cadenas que representa el estado actual de     * la palabra oculta, con guiones bajos para las letras no adivinadas.     * @param palabraSecreta la palabra secreta que el jugador está intentando     * adivinar.     * @param opciones el número de opciones disponibles para la pista. Un valor     * de 2 o 3 se utiliza para decidir entre las diferentes pistas.     */    public static void proporcionarAyuda(int[] fallos, String[] guiones, String [] palabraSecreta, int opciones) {        mostrarOpcionesAyuda();        // Generamos un número aleatorio para seleccionar la opción de ayuda        int numero = (int) (Math.random() * opciones) + 1;        switch (numero) {            case 1:                System.out.println("Te he eliminado un fallo.");                fallos[0]--;  // Eliminar un fallo                break;            case 2:                if (esVocal(palabraSecreta[0].charAt(0))) {                    System.out.println("Te he añadido una vocal sin sumar fallos.");                    darVocal(guiones, palabraSecreta);  // Añadir una vocal                } else {                    System.out.println("Te he añadido una consonante sin sumar fallos.");                    darConsonante(guiones, palabraSecreta);  // Añadir una consonante                }                verificarPalabraCompletada(guiones, palabraSecreta);                break;            case 3:                System.out.println("Te he añadido una consonante sin sumar fallos.");                darConsonante(guiones, palabraSecreta);  // Añadir una consonante                verificarPalabraCompletada(guiones, palabraSecreta);                break;        }    }    /**     * Proporciona al usuario la opción de rendirse o recibir una pista.     * <p>     * Este método se ejecuta cuando el jugador alcanza 3 fallos. Permite al     * jugador decidir entre rendirse (lo que termina el juego) o recibir una     * pista aleatoria que puede ayudarle a continuar.     *     * @param fallos el número actual de fallos cometidos por el jugador.     * @param guiones un array que representa el estado actual de la palabra     * oculta, con guiones bajos para letras no adivinadas.     * @param palabraSecreta la palabra secreta que el jugador está tratando de     * adivinar.     */    public static void darPistaRendirse(int[] fallos, String[] guiones, String[]palabraSecreta) {        String regex = "^(SI|-1)$";        String respuesta;        Scanner t = new Scanner(System.in);        System.out.println("¿Quieres rendirte? Si es así marca -1, sino marca SI");        do {            respuesta = t.nextLine().toUpperCase();            if (respuesta.equals("-1")) {                System.out.println("Te has rendido, fin del juego.");                System.out.println("La palabra era: " + Arrays.toString(palabraSecreta) );                System.exit(0);            } else if (respuesta.equals("SI")) {                gestionAyuda(fallos, guiones, palabraSecreta);            }        } while (!Pattern.matches(regex, respuesta));  // Asegura que solo se acepte "SI" o "-1"    }    public static void mostrarOpcionesAyuda() {        System.out.println("""                       \u00a1Estas de suerte! Hay 3 opciones que te ayudar\u00e1n a ganar el juego, te dar\u00e9 una de forma aleatoria:                                              - Restarte un fallo                       - Darte una vocal                       - O darte una consonante                       """);    }    /**     * Prepara el juego seleccionando una palabra secreta del archivo del     * Quijote.     * <p>     * Este método filtra palabras de parada, selecciona palabras con 5 o más     * caracteres, y elige una al azar.     * </p>     *     * @return la palabra secreta seleccionada.     * @throws IOException si ocurre un error al leer los archivos.     */    public static String [] prepararJuego() throws IOException {        String quijote = "Quijote_completo.txt";        String stop = "stop_words.txt";        String[] palabrasQuijote = leerSepararPalabras(quijote);        String[] palabrasStop = leerSepararPalabras(stop);        // Filtrar palabras que no están en las stop words        String[] palabrasNoStop = eliminarPalbrasStop(palabrasQuijote, palabrasStop);        // Filtrar palabras según el tamaño adecuado        String[] palabrasMasCarcteres = palabras5caracteres(palabrasNoStop);        // Elegir aleatoriamente la palabra secreta        String [] palabraSecreta = palabraRandom(palabrasMasCarcteres);        return palabraSecreta;    }    /**     * Ejecuta la lógica principal del juego, permitiendo al jugador     * interactuar.     * <p>     * El método gestiona los turnos del jugador, verifica las letras adivinadas     * y proporciona retroalimentación según los intentos.     * </p>     *     * @param palabraSecreta la palabra que el jugador debe adivinar.     */    public static void juego(String [] palabraSecreta) {        String[] palabrasUsadas = new String[27];        Arrays.fill(palabrasUsadas,"");        String[] guiones = crearGuiones(palabraSecreta);        int[] fallos = {0};        String regex = "[A-ZÑÜ]";        int indexUsadas = 0;        Scanner t = new Scanner(System.in);        System.out.println("¡Bienvenido al Juego del Ahorcado!");        imprimirReglas();        if (!t.nextLine().toUpperCase().equals("SI")) {            return;        }        System.out.println("Comenzamos, este es el tamaño de la palabra que vas a adivinar:");        System.out.println(Arrays.toString(guiones));        while (fallos[0] < 6) {            System.out.print("Dime una letra: ");            String entrada = t.next().toUpperCase();            if (Pattern.matches(regex, entrada)) { //Validar entrada con regex                char letra = entrada.charAt(0);                if (estaLetra(letra, palabrasUsadas)) {                    System.out.println("Ya has usado esta letra. Intenta con otra.");                } else {                    palabrasUsadas[indexUsadas++]=String.valueOf(letra);                    if (estaLetra(letra, palabraSecreta)) {                        guiones = rellenar(guiones, letra, palabraSecreta);                        System.out.println(Arrays.toString(guiones) + "\n");                        System.out.println("PALABRAS USADAS: " + Arrays.toString(palabrasUsadas) + "\n");                        if (Arrays.equals(guiones, palabraSecreta)) {                            System.out.println("¡Felicidades, has ganado el juego!");                            return;                        }                    } else {                        fallos[0]++;                        System.out.println("Ups, fallaste. Intentos restantes: " + (6 - fallos[0]));                        System.out.println(Arrays.toString(guiones) + "\n");                        System.out.println("PALABRAS USADAS: " + Arrays.toString(palabrasUsadas) + "\n");                        fallos[0] = manejarFallos(fallos, guiones, palabraSecreta);                    }                }            } else {                System.out.println("Entrada no válida. Por favor, ingresa solo letras mayúsculas.");            }        }    }    /**     * Maneja las consecuencias de los fallos durante el juego.     * <p>     * Muestra las partes del ahorcado correspondientes a cada fallo e incluye     * lógica para dar pistas al jugador en el caso de alcanzar un cierto número     * de fallos.     * </p>     *     * @param fallos el número actual de fallos del jugador.     * @param guiones el estado actual de la palabra oculta.     * @param palabraSecreta la palabra secreta que el jugador intenta adivinar.     * @return el número actualizado de fallos.     */    private static boolean AYUDA_DADA = false;    public static int manejarFallos(int[] fallos, String[] guiones, String[] palabraSecreta) {        switch (fallos[0]) {            case 1 ->                System.out.println(cabezaAhorcado());            case 2 ->                System.out.println(troncoAhorcado());            case 3 ->                System.out.println(brazoDechAhorcado());            case 4 -> {                if (!AYUDA_DADA) {                    darPistaRendirse(fallos, guiones, palabraSecreta);                    AYUDA_DADA = true;                } else {                    System.out.println(brazoIzqAhorcado());                }            }            case 5 ->                System.out.println(piernaDechAhorcado());            case 6 -> {                System.out.println(piernaIzqAhorcado());                System.out.println("Lo siento perdistes el juego,la palabra era:" + Arrays.toString(palabraSecreta) );                break;            }        }        return fallos[0];    }}